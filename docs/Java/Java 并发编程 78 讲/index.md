# Java 并发编程 78 讲

- [00 由点及面，搭建你的 Java 并发知识网](./第00讲.md)
- [01 为何说只有 1 种实现线程的方法？](./第01讲.md)
- [02 如何正确停止线程？为什么 volatile 标记位的停止方法是错误的？](./第02讲.md)
- [03 线程是如何在 6 种状态之间转换的？](./第03讲.md)
- [04 waitnotifynotifyAll 方法的使用注意事项？](./第04讲.md)
- [05 有哪几种实现生产者消费者模式的方法？](./第05讲.md)
- [06 一共有哪 3 类线程安全问题？](./第06讲.md)
- [07 哪些场景需要额外注意线程安全问题？](./第07讲.md)
- [08 为什么多线程会带来性能问题？](./第08讲.md)
- [09 使用线程池比手动创建线程好在哪里？](./第09讲.md)
- [10 线程池的各个参数的含义？](./第10讲.md)
- [11 线程池有哪 4 种拒绝策略？](./第11讲.md)
- [12 有哪 6 种常见的线程池？什么是 Java8 的 ForkJoinPool？](./第12讲.md)
- [13 线程池常用的阻塞队列有哪些？](./第13讲.md)
- [14 为什么不应该自动创建线程池？](./第14讲.md)
- [15 合适的线程数量是多少？CPU 核心数和线程数的关系？](./第15讲.md)
- [16 如何根据实际需要，定制自己的线程池？](./第16讲.md)
- [17 如何正确关闭线程池？shutdown 和 shutdownNow 的区别？](./第17讲.md)
- [18 线程池实现“线程复用”的原理？](./第18讲.md)
- [19 你知道哪几种锁？分别有什么特点？](./第19讲.md)
- [20 悲观锁和乐观锁的本质是什么？](./第20讲.md)
- [21 如何看到 synchronized 背后的“monitor 锁”？](./第21讲.md)
- [22 synchronized 和 Lock 孰优孰劣，如何选择？](./第22讲.md)
- [23 Lock 有哪几个常用方法？分别有什么用？](./第23讲.md)
- [24 讲一讲公平锁和非公平锁，为什么要“非公平”？](./第24讲.md)
- [25 读写锁 ReadWriteLock 获取锁有哪些规则？](./第25讲.md)
- [26 读锁应该插队吗？什么是读写锁的升降级？](./第26讲.md)
- [27 什么是自旋锁？自旋的好处和后果是什么呢？](./第27讲.md)
- [28 JVM 对锁进行了哪些优化？](./第28讲.md)
- [29 HashMap 为什么是线程不安全的？](./第29讲.md)
- [30 ConcurrentHashMap 在 Java7 和 8 有何不同？](./第30讲.md)
- [31 为什么 Map 桶中超过 8 个才转为红黑树？](./第31讲.md)
- [32 同样是线程安全，ConcurrentHashMap 和 Hashtable 的区别](./第32讲.md)
- [33 CopyOnWriteArrayList 有什么特点？](./第33讲.md)
- [34 什么是阻塞队列？](./第34讲.md)
- [35 阻塞队列包含哪些常用的方法？add、offer、put 等方法的区别？](./第35讲.md)
- [36 有哪几种常见的阻塞队列？](./第36讲.md)
- [37 阻塞和非阻塞队列的并发安全原理是什么？](./第37讲.md)
- [38 如何选择适合自己的阻塞队列？](./第38讲.md)
- [39 原子类是如何利用 CAS 保证线程安全的？](./第39讲.md)
- [40 AtomicInteger 在高并发下性能不好，如何解决？为什么？](./第40讲.md)
- [41 原子类和 volatile 有什么异同？](./第41讲.md)
- [42 AtomicInteger 和 synchronized 的异同点？](./第42讲.md)
- [43 Java 8 中 Adder 和 Accumulator 有什么区别？](./第43讲.md)
- [44 ThreadLocal 适合用在哪些实际生产的场景中？](./第44讲.md)
- [45 ThreadLocal 是用来解决共享资源的多线程访问的问题吗？](./第45讲.md)
- [46 多个 ThreadLocal 在 Thread 中的 threadlocals 里是怎么存储的？](./第46讲.md)
- [47 内存泄漏——为何每次用完 ThreadLocal 都要调用 remove()？](./第47讲.md)
- [48 Callable 和 Runnable 的不同？](./第48讲.md)
- [49 Future 的主要功能是什么？](./第49讲.md)
- [50 使用 Future 有哪些注意点？Future 产生新的线程了吗？](./第50讲.md)
- [51 如何利用 CompletableFuture 实现“旅游平台”问题？](./第51讲.md)
- [52 信号量能被 FixedThreadPool 替代吗？](./第52讲.md)
- [53 CountDownLatch 是如何安排线程执行顺序的？](./第53讲.md)
- [54 CyclicBarrier 和 CountdownLatch 有什么异同？](./第54讲.md)
- [55 Condition、object.wait() 和 notify() 的关系？](./第55讲.md)
- [56 讲一讲什么是 Java 内存模型？](./第56讲.md)
- [57 什么是指令重排序？为什么要重排序？](./第57讲.md)
- [58 Java 中的原子操作有哪些注意事项？](./第58讲.md)
- [59 什么是“内存可见性”问题？](./第59讲.md)
- [60 主内存和工作内存的关系？](./第60讲.md)
- [61 什么是 happens-before 规则？](./第61讲.md)
- [62 volatile 的作用是什么？与 synchronized 有什么异同？](./第62讲.md)
- [63 单例模式的双重检查锁模式为什么必须加 volatile？](./第63讲.md)
- [64 你知道什么是 CAS 吗？](./第64讲.md)
- [65 CAS 和乐观锁的关系，什么时候会用到 CAS？](./第65讲.md)
- [66 CAS 有什么缺点？](./第66讲.md)
- [67 如何写一个必然死锁的例子？](./第67讲.md)
- [68 发生死锁必须满足哪 4 个条件？](./第68讲.md)
- [69 如何用命令行和代码定位死锁？](./第69讲.md)
- [70 有哪些解决死锁问题的策略？](./第70讲.md)
- [71 讲一讲经典的哲学家就餐问题](./第71讲.md)
- [72 final 的三种用法是什么？](./第72讲.md)
- [73 为什么加了 final 却依然无法拥有“不变性”？](./第73讲.md)
- [74 为什么 String 被设计为是不可变的？](./第74讲.md)
- [75 为什么需要 AQS？AQS 的作用和重要性是什么？](./第75讲.md)
- [76 AQS 的内部原理是什么样的？](./第76讲.md)
- [77 AQS 在 CountDownLatch 等类中的应用原理是什么？](./第77讲.md)
- [78 一份独家的 Java 并发工具图谱](./第78讲.md)
